>**<p align="center">Take control of SQL statements sent to the database</p>**
<br>

You can take care of several things about SQL statements to promote performance and scalability at the beginning of application development.
* Limit JDBC roundtrips
  * Detect N+1 selects by using [@ExpectSelect](#ExpectSelect), [@ExpectMaxSelect](#ExpectMaxSelect) or [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams)<br> 
  * Detect JDBC batching disabled by using [@ExpectJdbcBatching](#ExpectJdbcBatching)
  * Detect exactly same selects by using [@DisableExactlySameSelects](#DisableExactlySameSelects)

  *[Why limit JDBC roundtrips?](https://blog.jooq.org/2017/12/18/the-cost-of-jdbc-server-roundtrips/)*

* Limit fetched data
  * Detect too many selected columns by using [@ExpectSelectedColumn](#ExpectSelectedColumn) or [@ExpectMaxSelectedColumn](#ExpectMaxSelectedColumn)<br><br>
*[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns%3F)*
* Avoid SQL statements having a LIKE pattern starting with a wildcard by using [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard)

* Avoid cross join generated by Criteria API by using [@DisableCrossJoin](#DisableCrossJoin)
* ...

***Do little configuration described in [**Quick start**](#Quick-start) before using SQL annotations.***

# 🚩 Table of contents
[**Quick start**](#Quick-start)<br>

[**Worflow with SQL annotations**](#Worflow-with-SQL-annotations)<br>

[**Recommended global annotations**](#Recommended-global-annotations)<br>

[**Cancel the behavior of global annotations**](#Cancel-the-behavior-of-global-annotations)<br>

[**Recommended method annotations**](#Recommended-method-annotations)<br>

[**Debug annotations**](#Debug-annotations)<br>

# Quick start
## Add configuration 
### [Configuration for Spring](https://github.com/quick-perf/doc/wiki/Spring)
### [Configuration for JUnit 4](https://github.com/quick-perf/doc/wiki/JUnit-4)

## Check the configuration
To check that the configuration is properly done, you can try to add an annotation on a test method in order to make it fail. For example, add @ExpectSelect(0) on a test method that is supposed to send one or several selects to the database.
If you seem to have twice more (or several times more) statements than expected, check that you don't have this messsage in the console:
```
[WARNING] QuickPerf has built several datasource proxies
```
For example, you may have declared twice a QuickPerfProxyBeanPostProcessor bean in your Spring configuration:
```   
    @Bean
    public QuickPerfProxyBeanPostProcessor quickPerfProxyBeanPostProcessor1() {
        return new QuickPerfProxyBeanPostProcessor();
    }

    @Bean
    public QuickPerfProxyBeanPostProcessor quickPerfProxyBeanPostProcessor2() {
        return new QuickPerfProxyBeanPostProcessor();
    }
```

## Use SQL annotations
Use [global annotations](#Recommended-global-annotations) or [method](#Recommended-method-annotations) annotations. See [the workflow part](#Worflow-with-SQL-annotations) to see ways to work with SQL annotations.

## Automatic framework detection
The SQL annotations automatically detect if *Hibernate* or *Spring* frameworks are used. You don't have any configuration to do. If a SQL property is not respected, the SQL annotations can suggest you solutions to fix it with these frameworks.

For example, the following message is diplayed when a N+1 select is presumed and Spring Data JPA is detected:
```
	* With Spring Data JPA, you may fix it by adding
	@EntityGraph(attributePaths = { "..." }) on repository method.
	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.entity-graph
```


# Worflow with SQL annotations


# Recommended global annotations

## Configure recommended global annotations
A SqlAnnotationBuilder class is available to easily implement SpecifiableGlobalAnnotations.

```java
package org.quickperf;

import org.quickperf.config.user.SpecifiableGlobalAnnotations;
import org.quickperf.sql.annotation.SqlAnnotationBuilder;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;

import static org.quickperf.sql.annotation.SqlAnnotationBuilder.*;

public class QuickPerfConfiguration implements SpecifiableGlobalAnnotations {

    public Collection<Annotation> specifyAnnotationsAppliedOnEachTest() {
        return Arrays.asList(  disableSameSelectTypesWithDifferentParams() // can reveal some N+1 selects
                             , disableExactlySameSelects() // can reveal a bad use of Hibernate session
                             , expectJdbcBatching()
                           //, disableCrossJoin() // if you use JPA Criteria API
                             , disableLikeWithLeadingWildcard()
                             );
    }

}
```
**A class implementing SpecifiableGlobalAnnotations has to be in org.quickperf package.**

## @DisableExactlySameSelects

## @DisableSameSelectTypesWithDifferentParams

## @DisableLikeWithLeadingWildcard
Verify that SQL statements do not contain LIKE with leading wildcard (% or _).<br>

You can read this [article](https://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning) explaining why LIKE with leading wildcard could be a bad idea in term of performance.<br>

A code sending to the database a like with leading wilcard may be fast in a test having a few data but very slow with the data volume of production.

## @ExpectJdbcBatching

Verify that inserts, deletes and updates are processed in JDBC batches having *batchSize* elements.

You may sometimes think that you are using JDBC batching but in fact not ([Paper 1](https://abramsm.wordpress.com/2008/04/23/hibernate-batch-processing-why-you-may-not-be-using-it-even-if-you-think-you-are/), [Paper 2](https://stackoverflow.com/questions/27697810/hibernate-disabled-insert-batching-when-using-an-identity-identifier))!

*Batching  of inserts, updates and deletes allows to reduce the number of [roundtrips to the database which can dramatically impact application performance](https://blog.jooq.org/2017/12/18/the-cost-of-jdbc-server-roundtrips/).*

You can decide to batch all inserts, updates, delete. Prior to Hibernate 5.2, batching, when enabled with a hibernate.jdbc.batch_size property stricly positive, was applied to all inserts, updates and deletes (from Hibernate 5.2 it is also possible to override the batch size value for a given session).

### Parameters 
|Parameter  |Type| Meaning           | Default value  |
| -------- |:---:|:-----------------:|:--------------:|
| batchSize| int |JDBC batch size   |      -         |

_batchSize is optional._

A 0 batch size means that JDBC batching is disabled.

### Example
```java
    @ExpectJdbcBatching(batchSize = 30)
```

## @DisableCrossJoin
[Cross join can be generated by JPA Criteria API and can impact performance](https://vladmihalcea.com/hibernate-facts-always-check-criteria-api-sql-queries/).
 

# Cancel the behavior of global annotations

## @EnableExactlySameSelects
Cancel behavior of [@DisableExactlySameSelects](#DisableExactlySameSelects).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why exactly same selects are enabled|      -         |

## @EnableSameSelectTypesWithDifferentParams
Cancel behavior of [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams).

### Parameters 
|Parameter|Type    | Meaning                                                               | Default value  |
| --------|:------:|:----------------------------------------------------------------------|:--------------:|
| comment | String |Comment why exactly same select types with different parameters are enabled|      -         |

## @EnableCrossJoin
Cancel behavior of [@DisableCrossJoin](#DisableCrossJoin).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why cross join is enabled   |      -         |

## @EnableLikeWithLeadingWildcard
Cancel behavior of [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard).

### Parameters 
|Parameter|Type    | Meaning                                         | Default value  |
| --------|:------:|:------------------------------------------------|:--------------:|
| comment | String |Comment why like with leading wildcard is enabled|      -         |

## @ExpectJdbcBatching(batchSize=0)
Indicate disabling of JDBC batching.

# Recommended method annotations

## @ExpectSelect

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of select statements|        0       |

### Example
```java
    @ExpectSelect(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```
## @ExpectMaxSelect
With this annotation, the test will fail if the number of SELECT statements is greater than expected. 
### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Maximum number of selects  |        0       |

### Example
```java
    @ExpectMaxSelect(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```

## @ExpectSelectedColumn

Verifies the number of selected columns. <br>

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                     | Default value  |
| --------  |:---:|:--------------------------:|:--------------:|
| value     | int |Number of selected columns  |        0       |

### Example
```java
    @ExpectSelectedColumn(3)
```

## @ExpectMaxSelectedColumn

With this annotation, the test will fail if the number of returned columns is greater than expected.

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                             | Default value  |
| --------  |:---:|:----------------------------------:|:--------------:|
| value     | int |Maximum number of returned columns  |        0       |
### Example
```java
    @ExpectMaxSelectedColumn(5)
```

## @ExpectInsert

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of insert statements  |        0       |

## @ExpectUpdate

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of update statements|        0       |

## @ExpectDelete

|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of delete statements|        0       |

# Debug annotations
## [@DisplayAppliedAnnotations](https://github.com/quick-perf/doc/wiki/Base-annotations)

## @DisplaySqlOfTestMethodBody
With this annotation the SQL statements are diplayed in the console during the execution of the test method body. <br>

Compared to [@DisplaySql](#DisplaySql), this annotation does not diplay SQL statements before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

⚠️ *It is not recommended to commit your test with this annotation. Indeed, the SQL statements would pollute the logs and may slow down the continuous integration build.*

## @DisplaySql
With this annotation the SQL statements are diplayed in the console during the test execution.<br>

Compared to [@DisplaySqlOfTestMethodBody](#DisplaySqlOfTestMethodBody), this annotation also diplays SQL statements before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

⚠️ *It is not recommended to commit your test with this annotation. Indeed, the SQL statements would pollute the logs and may slow down the continuous integration build.*

