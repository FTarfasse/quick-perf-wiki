***<p align="center">Take control of SQL requests sent to the database.</p>***
<br>
Several antipatterns can be detected with SQL annotations:
* N+1 selects by using [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams), [@SelectNumber](#SelectNumber) or [@MaxOfSelects](#MaxOfSelects)
* JDBC batching disabled by using [@JdbcBatching](#JdbcBatching)
* SQL requests having a LIKE pattern starting with a wildcard by using [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard)
* Too many selected columns by using [@SelectedColumnsNumber](#SelectedColumnsNumber) or [@MaxOfSelectedColumns](#MaxOfSelectedColumns)<br>
*[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)*
* Bad use of Hibernate session by using [@DisableExactlySameSelects](#DisableExactlySameSelects)
* Cross join generated by Criteria API by using [@DisableCrossJoin](#DisableCrossJoin)
* ...

[**Configuration to do before using SQL annotations**](#Configuration-to-do-before-using-SQL-annotations)<br>

[**Worflow with SQL annotations**](#Worflow-with-SQL-annotations)<br>

[**Recommended global annotations**](#Recommended-global-annotations)<br>

[**Disable some global annotations**](#Disable-some-global-annotations)<br>

[**Recommended method annotations**](#Recommended-method-annotations)<br>

[**Debug annotations**](#Debug-annotations)<br>

# Configuration to do before using SQL annotations
[Configuration with JUnit 4 (without Spring)](https://github.com/quick-perf/doc/wiki/QuickPerfRunner-&-SQL-annotations)<br><br>
[Configuration with JUnit 4 and Spring](https://github.com/quick-perf/doc/wiki/QuickPerfSpringRunner-&-SQL-annotations)

The SQL annotations automatically detect if you use *Hibernate* or *Spring Boot* framewoks. If a SQL property is not respected, the SQL annotations can suggest you solutions to fix it with *Hibernate* or *Spring BoAdd some performance checks to existing database testsot*.

# Worflow with SQL annotations
Below, propose ways to use SQL annotations during development.<br>

[Configure global annotations](#Configure-global-annotations)<br>
[Implementation of a new business use case](#Implementation-of-a-new-business-use-case)<br>
[Add some performance checks to existing database tests](#Add-some-performance-checks-to-existing-database-tests)<br>

## Configure global annotations
Configure once some [recommended global annotations](#Recommended-global-annotations). These annotations are applied to every test method.<br> The idea is to systematically apply some performance checks to avoid some classical performance bottlenecks.

## Implementation of a new business use case
Firstly, we focus our work and attention on the functional behavior. The goal is to have something working without worrying about performances. *We try to do one thing at a time.* After, we check some performance properties.
### **Work on functional behavior** <br>
* **Write a test describing and verifying the *functional behavior*** <br> 
* **Annotate this test with *@DisableQuickPerf* or *@FunctionalIteration* to disable the QuickPerf annotations** <br>So, we disable annotations having global or class scopes. <br>
* **Make the functional behavior working** <br>
  You can do this applying a TDD approach (Red/Green/Refactor).
### **Work on performance behavior**
* **Remove @DisableQuickPerf or @FunctionalIteration to enable QuickPerf annotations** 
* **Fix or ignore issues reported by global annotations**
<br>In some specific cases, you can [disable some global annotations](#Disable-some-global-annotations).
* **Possibly add QuickPerf annotation on method to document the code** 

## Add some performance checks to existing database tests
You can introduce QuickPerf in a project having some database tests.<br>
After [the configuration of global annotations](#Recommended-global-annotations), some tests may fail because of some not respected performance properties.<br>
If you may want to progressively fix these failing tests. To do this, you could annotate the failing tests with @DisableGlobalAnnotations with a comment, for example @DisableGlobalAnnotations(comment="Investigate why global annotations are failing). After that, you could progressively remove the annotation and see why the tests are failing.

# Recommended global annotations

## Configure recommended global annotations
A SqlAnnotationBuilder class is available to easily implement SpecifiableAnnotations.

```java
package org.quickperf;

import org.quickperf.config.user.SpecifiableAnnotations;
import org.quickperf.sql.annotation.SqlAnnotationBuilder;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;

import static org.quickperf.sql.annotation.SqlAnnotationBuilder.*;

public class QuickPerfConfiguration implements SpecifiableAnnotations {

    public Collection<Annotation> specifyAnnotationsAppliedOnEachTest() {
        int batchSize = 30; // set the expected batch size
        return Arrays.asList(  disableSameSelectTypesWithDifferentParams() // can reveal N+1 selects
                             , disableExactlySameSelects() // can reveal a bad use of Hibernate session
                             , jdbcBatching(batchSize)
                           //, disableCrossJoin() // if you use JPA Criteria API
                             , disableLikeWithLeadingWildcard()
                             );
    }

}
```
**The class implementing SpecifiableAnnotations has to be in org.quickperf package.**

## @DisableExactlySameSelects

## @DisableSameSelectTypesWithDifferentParams

## @DisableLikeWithLeadingWildcard
Verifies that SQL requests do not contain LIKE with leading wildcard (% or _).<br>

You can read this [article](https://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning) explaining why LIKE with leading wildcard could be a bad idea in term of performance.

## @JdbcBatching

Verifies that inserts, deletes and updates are processed in JDBC batches having *batchSize* elements.

You may sometimes think that you are using JDBC batching but in fact not ([Paper 1](https://abramsm.wordpress.com/2008/04/23/hibernate-batch-processing-why-you-may-not-be-using-it-even-if-you-think-you-are/), [Paper 2](https://stackoverflow.com/questions/27697810/hibernate-disabled-insert-batching-when-using-an-identity-identifier))!

*Batching  of inserts, updates and deletes allows to reduce the number of [roundtrips to the database which can dramatically impact application performance](https://blog.jooq.org/2017/12/18/the-cost-of-jdbc-server-roundtrips/).*

You can decide to batch all inserts, updates, delete. Prior to Hibernate 5.2, batching, when enabled with a hibernate.jdbc.batch_size property stricly positive, was applied to all inserts, updates and deletes (from Hibernate 5.2 it is also possible to override the batch size value for a given session).

### Parameters 
|Parameter  |Type| Meaning           | Default value  |
| -------- |:---:|:-----------------:|:--------------:|
| batchSize| int |JDBC batch size    |      -         |

A 0 batch size means that JDBC batching is disabled.

### Example
```java
    @JdbcBatching(batchSize = 30)
```

## @DisableCrossJoin
[Cross join can be generated by JPA Criteria API and can impact performance](https://vladmihalcea.com/hibernate-facts-always-check-criteria-api-sql-queries/).
 

# Disable some global annotations

## @EnableExactlySameSelects
Cancels behavior of [@DisableExactlySameSelects](#DisableExactlySameSelects).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why exactly same selects are enabled|      -         |

## @EnableSameSelectTypesWithDifferentParams
Cancels behavior of [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams).

### Parameters 
|Parameter|Type    | Meaning                                                               | Default value  |
| --------|:------:|:----------------------------------------------------------------------|:--------------:|
| comment | String |Comment why exactly same select types with different parameters are enabled|      -         |

## @EnableCrossJoin
Cancels behavior of [@DisableCrossJoin](#DisableCrossJoin).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why cross join is enabled   |      -         |

## @EnableLikeWithLeadingWildcard
Cancels behavior of [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard).

### Parameters 
|Parameter|Type    | Meaning                                         | Default value  |
| --------|:------:|:------------------------------------------------|:--------------:|
| comment | String |Comment why like with leading wildcard is enabled|      -         |

## @JdbcBatching(batchSize=0)
Indicates disabling of JDBC batching.

# Recommended method annotations

## @SelectedColumnsNumber

Verifies the number of selected columns. <br>

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                     | Default value  |
| --------  |:---:|:--------------------------:|:--------------:|
| value     | int |Number of selected columns  |        0       |

### Example
```java
    @SelectedColumnsNumber(3)
```

## @MaxOfSelectedColumns

With this annotation, the test will fail if the number of returned columns is greater than expected.

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                             | Default value  |
| --------  |:---:|:----------------------------------:|:--------------:|
| value     | int |Maximum number of returned columns  |        0       |
### Example
```java
    @MaxOfSelectedColumns(5)
```

## @SelectNumber

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of select requests  |        0       |

### Example
```java
    @SelectNumber(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```
## @MaxOfSelects
With this annotation, the test will fail if the number of SELECT requests is greater than expected. 
### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Maximum number of selects  |        0       |

### Example
```java
    @MaxOfSelects(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```
## @InsertNumber

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of insert requests  |        0       |

## @UpdateNumber

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of update requests  |        0       |

## @DeleteNumber

|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of delete requests  |        0       |

# Debug annotations
## [@DisplayAppliedAnnotations](https://github.com/quick-perf/doc/wiki/Base-annotations)

## @DisplaySqlOfTestMethodBody
With this annotation the SQL orders are diplayed in the console during the execution of the test method body. <br>

Compared to [@DisplaySql](#DisplaySql), this annotation does not diplay SQL orders before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

*It is not recommended to commit your test with this annotation. Indeed, the displaying of SQL orders would pollute the logs of your continuous integration build and it may slow down your continuous integration build.*

## @DisplaySql
With this annotation the SQL orders are diplayed in the console during the test execution.<br>

Compared to [@DisplaySqlOfTestMethodBody](#DisplaySqlOfTestMethodBody), this annotation also diplays SQL orders before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

*It is not recommended to commit your test with this annotation. Indeed, the displaying of SQL orders would pollute the logs of your continuous integration build and it may slow down your continuous integration build.*



