***<p align="center">Take control of SQL requests sent to the database</p>***
<br>
You can take care of several things about SQL requests to favor performance and scalability at the beginning of application development.
* Limit JDBC roundtrips
  * Detect N+1 selects by using [@ExpectSelect](#ExpectSelect), [@ExpectMaxSelect](#ExpectMaxSelect) or [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams)<br> 
  * Detect JDBC batching disabled by using [@ExpectJdbcBatching](#ExpectJdbcBatching)
  * Detect exactly same selects by using [@DisableExactlySameSelects](#DisableExactlySameSelects)

  *[Why limit JDBC roundtrips?](https://blog.jooq.org/2017/12/18/the-cost-of-jdbc-server-roundtrips/)*

* Limit fetched data
  * Detect too many selected columns by using [@ExpectSelectedColumn](#ExpectSelectedColumn) or [@ExpectMaxSelectedColumn](#ExpectMaxSelectedColumn)<br><br>
*[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns%3F)*
* Avoid SQL requests having a LIKE pattern starting with a wildcard by using [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard)

* Avoid cross join generated by Criteria API by using [@DisableCrossJoin](#DisableCrossJoin)
* ...

***Do little configuration described in [**Quick start**](#Quick-start) before using SQL annotations.***

# Outline
[**Quick start**](#Quick-start)<br>

[**Worflow with SQL annotations**](#Worflow-with-SQL-annotations)<br>

[**Recommended global annotations**](#Recommended-global-annotations)<br>

[**Cancel the behavior of global annotations**](#Cancel-the-behavior-of-global-annotations)<br>

[**Recommended method annotations**](#Recommended-method-annotations)<br>

[**Debug annotations**](#Debug-annotations)<br>

# Quick start
[Configuration with JUnit 4 (without Spring)](https://github.com/quick-perf/doc/wiki/JUnit-4-&--SQL-annotations)<br><br>
[Configuration with JUnit 4 and Spring](https://github.com/quick-perf/doc/wiki/JUnit-4-&-Spring-&-SQL-annotations)

Use [global annotations](#Recommended-global-annotations) or [method](#Recommended-method-annotations) annotations. See [the workflow part](#Worflow-with-SQL-annotations) to see ways to work with SQL annotations.

The SQL annotations automatically detect if you use *Hibernate* or *Spring Boot* framewoks. You have no configuration to do. If a SQL property is not respected, the SQL annotation can suggest you solutions to fix it with these frameworks.

# Worflow with SQL annotations


# Recommended global annotations

## Configure recommended global annotations
A SqlAnnotationBuilder class is available to easily implement SpecifiableAnnotations.

```java
package org.quickperf;

import org.quickperf.config.user.SpecifiableAnnotations;
import org.quickperf.sql.annotation.SqlAnnotationBuilder;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;

import static org.quickperf.sql.annotation.SqlAnnotationBuilder.*;

public class QuickPerfConfiguration implements SpecifiableAnnotations {

    public Collection<Annotation> specifyAnnotationsAppliedOnEachTest() {
        return Arrays.asList(  disableSameSelectTypesWithDifferentParams() // can reveal some N+1 selects
                             , disableExactlySameSelects() // can reveal a bad use of Hibernate session
                             , expectJdbcBatching()
                           //, disableCrossJoin() // if you use JPA Criteria API
                             , disableLikeWithLeadingWildcard()
                             );
    }

}
```
**The class implementing SpecifiableAnnotations has to be in org.quickperf package.**

## @DisableExactlySameSelects

## @DisableSameSelectTypesWithDifferentParams

## @DisableLikeWithLeadingWildcard
Verify that SQL requests do not contain LIKE with leading wildcard (% or _).<br>

You can read this [article](https://use-the-index-luke.com/sql/where-clause/searching-for-ranges/like-performance-tuning) explaining why LIKE with leading wildcard could be a bad idea in term of performance.<br>

A code sending to the database a like with leading wilcard may be fast in a test having a few data but very slow with the data volume of production.

## @ExpectJdbcBatching

Verifies that inserts, deletes and updates are processed in JDBC batches having *batchSize* elements.

You may sometimes think that you are using JDBC batching but in fact not ([Paper 1](https://abramsm.wordpress.com/2008/04/23/hibernate-batch-processing-why-you-may-not-be-using-it-even-if-you-think-you-are/), [Paper 2](https://stackoverflow.com/questions/27697810/hibernate-disabled-insert-batching-when-using-an-identity-identifier))!

*Batching  of inserts, updates and deletes allows to reduce the number of [roundtrips to the database which can dramatically impact application performance](https://blog.jooq.org/2017/12/18/the-cost-of-jdbc-server-roundtrips/).*

You can decide to batch all inserts, updates, delete. Prior to Hibernate 5.2, batching, when enabled with a hibernate.jdbc.batch_size property stricly positive, was applied to all inserts, updates and deletes (from Hibernate 5.2 it is also possible to override the batch size value for a given session).

### Parameters 
|Parameter  |Type| Meaning           | Default value  |
| -------- |:---:|:-----------------:|:--------------:|
| batchSize| int |JDBC batch size   |      -         |

_batchSize is optional._

A 0 batch size means that JDBC batching is disabled.

### Example
```java
    @ExpectJdbcBatching(batchSize = 30)
```

## @DisableCrossJoin
[Cross join can be generated by JPA Criteria API and can impact performance](https://vladmihalcea.com/hibernate-facts-always-check-criteria-api-sql-queries/).
 

# Cancel the behavior of global annotations

## @EnableExactlySameSelects
Cancel behavior of [@DisableExactlySameSelects](#DisableExactlySameSelects).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why exactly same selects are enabled|      -         |

## @EnableSameSelectTypesWithDifferentParams
Cancel behavior of [@DisableSameSelectTypesWithDifferentParams](#DisableSameSelectTypesWithDifferentParams).

### Parameters 
|Parameter|Type    | Meaning                                                               | Default value  |
| --------|:------:|:----------------------------------------------------------------------|:--------------:|
| comment | String |Comment why exactly same select types with different parameters are enabled|      -         |

## @EnableCrossJoin
Cancel behavior of [@DisableCrossJoin](#DisableCrossJoin).

### Parameters 
|Parameter|Type    | Meaning                                    | Default value  |
| --------|:------:|:-------------------------------------------|:--------------:|
| comment | String |Comment why cross join is enabled   |      -         |

## @EnableLikeWithLeadingWildcard
Cancel behavior of [@DisableLikeWithLeadingWildcard](#DisableLikeWithLeadingWildcard).

### Parameters 
|Parameter|Type    | Meaning                                         | Default value  |
| --------|:------:|:------------------------------------------------|:--------------:|
| comment | String |Comment why like with leading wildcard is enabled|      -         |

## @ExpectJdbcBatching(batchSize=0)
Indicate disabling of JDBC batching.

# Recommended method annotations

## @ExpectSelect

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of select requests  |        0       |

### Example
```java
    @ExpectSelect(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```
## @ExpectMaxSelect
With this annotation, the test will fail if the number of SELECT requests is greater than expected. 
### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Maximum number of selects  |        0       |

### Example
```java
    @ExpectMaxSelect(1)
    @Test
    public void should_retrieve_all_cars() {	
     //...
    }
```

## @ExpectSelectedColumn

Verifies the number of selected columns. <br>

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                     | Default value  |
| --------  |:---:|:--------------------------:|:--------------:|
| value     | int |Number of selected columns  |        0       |

### Example
```java
    @ExpectSelectedColumn(3)
```

## @ExpectMaxSelectedColumn

With this annotation, the test will fail if the number of returned columns is greater than expected.

**_[Why limit the number of selected columns?](https://github.com/quick-perf/doc/wiki/Why-limit-the-number-of-selected-columns-%3F)_**

### Parameters 
|Parameter  |Type| Meaning                             | Default value  |
| --------  |:---:|:----------------------------------:|:--------------:|
| value     | int |Maximum number of returned columns  |        0       |
### Example
```java
    @ExpectMaxSelectedColumn(5)
```

## @ExpectInsert

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of insert requests  |        0       |

## @ExpectUpdate

### Parameters 
|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of update requests  |        0       |

## @ExpectDelete

|Parameter  |Type| Meaning                   | Default value  |
| -------- |:---:|:-------------------------:|:--------------:|
| value    | int |Number of delete requests  |        0       |

# Debug annotations
## [@DisplayAppliedAnnotations](https://github.com/quick-perf/doc/wiki/Base-annotations)

## @DisplaySqlOfTestMethodBody
With this annotation the SQL orders are diplayed in the console during the execution of the test method body. <br>

Compared to [@DisplaySql](#DisplaySql), this annotation does not diplay SQL orders before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

*It is not recommended to commit your test with this annotation. Indeed, the displaying of SQL orders would pollute the logs of your continuous integration build and it may slow down your continuous integration build.*

## @DisplaySql
With this annotation the SQL orders are diplayed in the console during the test execution.<br>

Compared to [@DisplaySqlOfTestMethodBody](#DisplaySqlOfTestMethodBody), this annotation also diplays SQL orders before (JUnit 4: @Before, @BeforeClass) and after (JUnit 4: @After, @AfterClass) the execution of the test method body. <br>

*It is not recommended to commit your test with this annotation. Indeed, the displaying of SQL orders would pollute the logs of your continuous integration build and it may slow down your continuous integration build.*



